## Функции, процедуры, триггеры, курсоры

### Функции

- Функция является **детерминированной**, если при одном и том же заданном входном значении она всегда возвращает одно и то же значение.
- Функция является **недетерминированной**, если при одном и том же заданном входном значении она может возвращать разные значения.

Функции по типу возвращаемого значения:

1. Скалярная функция
2. Подставляемая табличная функция
3. Многооператорная табличная функция

```sql

### 1. Скалярные функции
CREATE FUNCTION [ имя-схемы. ] имя-функции 
( [ список-объявлений-параметров ] )
RETURNS скалярный-тип-данных
[ WITH список-опций-функций ]
[ AS ]
BEGIN
	тело-функции
	RETURN скалярное-выражение
END [ ; ] 

### Пример
CREATE FUNCTION dbo.AveragePrice() RETURNS smallmoney
WITH SCHEMABINDING AS
BEGIN
	RETURN (SELECT AVG(Price) FROM dbo.R)
END;
CREATE FUNCTION dbo.PriceDifference(@Price smallmoney) RETURNS smallmoney AS
BEGIN
	RETURN @Price - dbo.AveragePrice()
END;

— Вызов функции
SELECT Pname, Price, dbo.AveragePrice() AS Average, dbo.PriceDifference(Price) AS Difference FROM R
WHERE City='Смоленск'
```

```sql
### 2. Подставляемая табличная функция
CREATE FUNCTION [ имя-схемы. ] имя-функции 
( [ список-объявлений-параметров ] )
RETURNS TABLE
[ WITH список-опций-функций ]
[ AS ]
RETURN [ ( ] выражение-выборки [ ) ]
END [ ; ]

### Пример
CREATE FUNCTION dbo.FullSPJ()
RETURNS TABLE
AS
 	RETURN (SELECT S.Sname, P.Pname, J.Jname, SPJ.Qty
	FROM S INNER JOIN SPJ ON S.Sno=SPJ.Sno
 	INNER JOIN P ON P.Pno=SPJ.Pno
 	INNER JOIN J ON J.Jno=SPJ.Jno)

— Вызов функции
SELECT *
FROM dbo.FullSPJ()
```



```sql
### 3. Многооператорная табличная функция
CREATE FUNCTION [ имя-схемы. ] имя-функции 
( [ список-объявлений-параметров ] )
RETURNS @имя-возвращаемой-переменной TABLE определение-таблицы
[ WITH список-опций-функций ]
[ AS ]
BEGIN
RETURN
END [ ; ]

### Пример
CREATE FUNCTION dbo.fnGetReports ( @EmployeeID AS int )
RETURNS @Reports TABLE ( EmployeeID int NOT NULL, ReportsToID int NULL )
AS
DECLARE
	Employee: int
BEGIN
	INSERT INTO @Reports
	SELECT EmployeeID, ReportsTo FROM Employees
	WHERE EmployeeID = @EmployeeID;
	
	SELECT @Employee = MIN(EmployeeID) FROM Employees
	WHERE ReportsTo = @EmployeeID;
	
	WHILE @Employee IS NOT NULL
	BEGIN
		INSERT INTO @Reports
		SELECT *
	END
	RETURN
END;
```

### Процедура

```sql
### Хранимая процедура T-SQL 
CREATE PROCEDURE [ имя-схемы. ] имя-процедуры
[ список-объявлений-параметров ]
[ WITH список-опций-процедуры ]
[ FOR REPLICATION ]
AS
тело-процедуры
[ ;] 

### Пример
CREATE PROCEDURE dbo.Factorial @ValIn bigint, @ValOut bigint output
AS
BEGIN
     IF @ValIn > 20 BEGIN
     PRINT N'Входной параметр должен быть <= 20'
     RETURN -99
     END
     DECLARE @WorkValIn bigint, @WorkValOut bigint
     IF @ValIn != 1
     BEGIN
     SET @WorkValIn = @ValIn - 1
     PRINT @@NESTLEVEL
     EXEC dbo.Factorial @WorkValIn, @WorkValOut OUTPUT
     SET @ValOut = @WorkValOut * @ValIn
     END
     ELSE
     SET @ValOut = 1
END
— Вызов процедуры
DECLARE @FactIn int, @FactOut int
SET @FactIn = 8
EXEC dbo.Factorial @FactIn, @FactOut OUTPUT

PRINT N'Факториал ' + CONVERT(varchar(3),@FactIn) + N 'равен ' + CONVERT(varchar(20),@FactOut)
```

### Триггеры

**Триггер** - это хранимая процедура особого типа, которая выполняет одну или несколько команд в ответ на событие.

Триггеры:

- DDL
- DML

###### DDL-триггеры

Триггер DDL может активироваться, если выполняется такая инструкция, как ALTER SERVER CONFIGURATION, или если происходит удаление таблицы с использованием команды DROP TABLE.

```sql
### Пример триггера
CREATE TRIGGER safety
ON DATABASE
FOR DROP_TABLE, ALTER_TABLE AS
	PRINT 'You must disable Trigger "safety" to drop or alter tables!'
 	ROLLBACK;
```

###### DML-триггеры

Для поддержания согласованности и точности данных используются декларативные и процедурные методы. 

Триггеры применяются в следующих случаях: 

- если использование методов декларативной целостности данных не отвечает функциональным потребностям приложения. 
- если необходимо каскадное изменение через связанные таблицы в базе данных.
- если база данных денормализована и требуется способ автоматизированного обновления избыточных данных в нескольких таблицах;
- если необходимо сверить значение в одной таблице с неидентичным значением в другой таблице;
- если требуется вывод пользовательских сообщений и сложная обработка ошибок. 

###### Классы DML-триггеров

- INSTEAD OF. Триггеры этого класса выполняются в обход действий, вызывавших их срабатывание, заменяя эти действия. Например, обновление таблицы, в которой есть триггер INSTEAD OF, вызовет срабатывание этого триггера. В результате вместо оператора обновления выполняется код триггера. Это позволяет размешать в триггере сложные операторы обработки, которые дополняют действия оператора, модифицирующего таблицу. 
- AFTER/BEFORE. Триггеры этого класса исполняются после действия, вызвавшего срабатывание триггера. Они считаются классом триггеров по умолчанию. Между триггерами этих двух классов существует ряд важных отличий, показанных в таблице. 

```sql
### Синтаксис DML-триггеров
CREATE TRIGGER имя_триггера
ON имя_таблицы_или_представления
[ WITH ENCRYPTION ]
класс_триггера тип(ы)_триггера
[ WITH APPEND ]
[ NOT FOR REPLICATION ]
AS sql_инструкции

### Пример
CREATE TRIGGER AfterApdateSPJ
ON SPJ
AFTER UPDATE
AS
BEGIN
RAISERROR(N'Произошло обновление в таблице поставок',1,1)
END
```

### Курсоры

- По области видимости
  - Локальные
  - Глобальные
- По типу
  - Статические
  - Динамические
  - Управляемые набором ключей
  - Быстрые последовательные
- По способу перемещения по курсору
  - Последовательные
  - Прокрутка
- По способу распараллеливания курсора
  - READ_ONLY
  - SCROLL_LOCKS
  - OPTIMISTIC

```sql
DECLARE имя-курсора CURSOR
[область-видимости-имени-курсора]
...


```


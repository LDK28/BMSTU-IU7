# Лабораторные работы теория

## ЛР 4

## Символьный тип данных

### 01 - Дайте определение символьному типу данных.
- Символьный тип данных - тип данных, предназначенный для хранения одного символа в определенной кодировке.

### 02 - Ложен ли символ конца файла? Какое макроопределение соответствует символу конца файла?
- Символ конца файла не ложен. Реальное значение EOF является отрицательным числом, зависящим от системы(в основном -1).
- EOF - макроопределение, соответствующее символу конца файла.

### 03 - Ложен ли символ терминального нуля? Если ложен, то только ли он? Каково его представление в памяти?
- Символ терминального нуля ложен, так как он соответствует коду со значением 0.
- Ложен только он, так как одному коду соответствует только один символ, и у кода со значением 0 это символ '\0'.
- В памяти представлен как 0.

### 04 - Накладывает ли размер символа какие-либо ограничения на таблицы кодировки?
- Да. 1 байт - 256 символов, 2 байта - 65536 сирмволов

### 05 - Какие таблицы кодировки вам известны? Какие из них однобайтные?
- ASCII, Unicode(UTF-8, UTF-16, UTF-32).
- Однобайтные: ASCII, UTF-8. 

### 06 - Можно ли делать какие-либо предположения о положении тех или иных символов в таблице кодировки?
- Нет.

## Строка как структура данных

### 01 - Дайте определение строке, оканчивающейся нулем.
- Строка - это последовательность символов, заканчивающаяся и включающая первый нулевой символ. При этом длина строки – число символов, которые расположены до нулевого символа.

### 02 - Поясните, как работают договоренности сообщества на примере договоренности о терминальном нуле. Какие выводы вы можете сделать из определения строки?
- Имеется договорённость, что все строки оканчиваются терминальным нулём, поэтому все програмыы пишутся с учетом этого.

### 03 - Предложите свою реализацию функции strlen.
```c
	size_t my_strlen(const char *string)
	{
		size_t len = 0;
		while (*string)
		{
			++len;
			++string;
		}
		return len;
	}
```

### 04 - Предложите свою реализацию функции strcpy.
```c
	char *my_strcpy(char *string1, const char *string2)
	{
		char *temp = string;
		
		while(*string2)
			*string1++ = *string2++;
		*string1 = '\0';
		
		return temp;
	}
```

### 05 - Валиден ли вызов функции strcpy(str, str + 1)?
- Подобный вызов функции валиден, так как мы передаем копируемую строку на 1 короче, чем та в которую копируем, потому что передаем адресс на 2-ую букву строки.
Но в любом случае использование strncpy более безопасно, так как можно контролировать количество копируемых символов. 

### 06 - Дайте определение лексикографическому порядку на множестве строк.
- первые i символов строк s1 и s2 одинаковы, а символ s1[i+1] меньше символа s2[i+1]
(пример, "abc" < "abd" или "abc" < "bcd");
- все символы строк s1 и s2 одинаковы, но строка s1 короче строки s1 (пример, "abc" <
"abcd").

### 07 - Предложите свою реализацию функции strcmp.
```c
	char my_strcmp(const char *string1, const char *string2)
	{
		size_t i;
		
		for (i = 0; *(string1 + i) == *(string2 + i); ++i)
			if (*(string1 + i) == '\0')
				return 0;

		return *(s + i) - *(t + i);
	}
```
### 08 - Предложите свою реализацию функции strcat.
```c
	char *my_strcat(char *string1, char *string2)
	{
		char *temp = string1;
		
		while (*string1)
			string1++;
		while (*string2)
			*string1++ = *string2++
		*string1 = '\0'
		
		return temp;
	}
```

### 09 - Валиден ли вызов функции strcat(str, str)?
- Такой вызов функции валиден, если строка была объявлена как массив символов и было учтено, что её длина будет увеличиваться. Например:

```c
	char str[8] = {'1', '2', '3'};
	strcat(str, str);
```

- Если же строка была объявлена без учета размера - такой вызов не валиден. Например:

```c
	char str = "123";
	strcat(str, str);
```

- Но в любом случае использование strncat более безопасно, так как можно контролировать количество добавляемых символов. 

### 10 - Предложите свою реализацию функций strchr и strrchr. С чем может быть связано наличие в стандартной библиотеке двух функция?
```c
	const char*my_strchr(const char *string, int symbol)
	{
		while (*string)
		{
			if (*string == symbol)
				return string;
			++string;
		}
		if (*string == symbol)
			return string;
		return NULL;
	}

	const char*my_strrchr(const char *string, int symbol)
	{
		long length = 0;
		while (*string)
		{
			++length;
			++string;
		}
		string -= length;
		while (length >= 0)
		{
			if ((*(string + length)) == symbol)
				return string + length;
			--length;
		}
		return NULL;
	}
```

- В стандартной библиотеке 2 функции, так как одна выполняет поиск слева, а другая справа.(Возможно ответил неверно, так как не корректно понял вопрос)

### 11 - Существуют ли аналоги функций для работы со строками, безопасные относительно длины строки? 
- Такие функции предусмотренны в библиотеке string.h: strn...(str1, str2, n). 

### 12 - В каких случаях вы бы стали использовать безопасные аналоги?
- Я бы использовал безопасные аналоги во всех случаях, чтобы снять с себя ответственность за контроль длины строки.

### 13 - Предложите свою реализацию функции strtok, исходя из предположения, что вы можете пользоваться в данном случае глобальными переменными.
```c
	char *pos;
	
	char *my_strtok(char *sting, const char *delim)
	{
		char *token = NULL;

		if (sting == NULL)
			sting = pos;
		   
		sting += strspn(sting, delim);
		if (*sting != '\0')
		{
			token = sting;
			sting += strcspn(sting, delim);
			if (*sting != '\0')
			{
				*sting = '\0';
				sting++;
			}
		}
		pos = sting;
		return token;
	}
```

### 14 - Предложите свою реализацию функции split, возвращающей массив слов, составляющих исходную строку. Сравните функции split и strtok.
```c
	long split(const char *string, const char *delim, char words[][WMAX], size_t *array_len)
	{
		char word[WMAX];
		size_t word_len = 0;
		while (*string)
		{
			long check_let = 1, check_symb = 0;
			for (size_t j = 0; *(delim + j); ++j)
			{
				if (*string == *(delim + j))
				{
					check_let = 0;
					break;
				}
				if (*(string + 1) == *(delim + j))
					check_symb = 1;
			}
			if (check_let == 1)
			{
				*(word + word_len) = *string;
				++word_len;
				if (word_len > WMAX - 1)
					return LONG_WORD_ERROR;
				if (check_symb == 1)
				{
					*(word + word_len) = 0;
					long check = 1;
					for (size_t i = 0; i < *array_len; ++i)
					{
						if (strcmp(word, *(words + i)) == 0)
						{
							check = 0;
							break;
						}
					}
					if (check == 1)
					{
						for (size_t i = 0; i < word_len + 1; ++i)
							*(*(words + *array_len) + i) = *(word + i);
						++(*array_len);
					}
					word_len = 0;
				}
			}
			++string;
		}
		return EXIT_SUCCESS;
	}
```

- Функция strtok меняет саму строку, ставя на место символов терминальные нули, моя же функция split разбивает строку на слова без её изменения, но требует на вход также матрицу, в которую будут записаны слова, при этом ответственность за размеры этой матрицы возлагаются на пользователя.

### 15 - Назовите особенности функций с данными, сохраняющимися между вызовами, на примере функции strtok. В качестве ориентира можете воспользоваться указаниями в стандарте насчёт связи реализации функции strtok и реализации других функций по обработке строк.
- Такие функции должны использовать глобальные переменные, чтобы сохранять информацию о предыдущем вызове.
- Если говорить о strtok, то эта функция использует один статический буфер, изменяя его. У функций без работы с данными, сохраняющимися между вызовами, при каждом вызове создается новый буфер.

### 16 - Можно ли в качестве аргумента посылать в функцию strtok строчный литерал?
- Нет, так как согласно стандарту, изменять значение строкового литерала в ходе выполнения программы нельзя.

### 17 - Пусть строка в стиле языка Паскаль - массив символов, в котором на первой позиции хранится длина строки в виде символа. Как будут выглядеть аналоги всех функций по обработке строк для этой структуры данных? 
- Условия для циклов будут не str[i] != 0, а i < str[0]; нумерация символов будет не с 0, а с 1.

### 18 - Сравните строку, оканчивающуюся нулём, и строку в стиле языка Паскаль.
- В Паскале строка хранится как массив символов, но вместо нуля на конце в нулевом элементе хранится размер этого массива(от 1 до 255) в виде символа.
- Минус такого подхода: размер строки не превышает 255 символов;
- Плюс такого подхода: всегда можно узнать размер строки без цикла прохода по строке.

# Лабораторные работы теория

## ЛР 1

### 01 - Из каких частей состоит наша абстрактная машина, с которой мы работаем? На основе какой машины она построена? Опишите назначение и принцип работы каждой из частей.
- Наша машина построена на основе машины фон Неймана. Она состоит из:
- ОЗУ(Оперативная память или оперативное запоминающее устройство) - энергозависимая часть системы компьютерной памяти, в которой во время работы компьютера хранится выполняемый машинный код;
- ПЗУ(Постоянное запоминающее Устройство) - энергонезависимая память, используется для хранения массива неизменяемых данных;
- ЦПУ(Центральный процессор или центральное процессорное устройство) - устройство исполняющее машинные инструкции.

### 02 - Дайте определение "машинному слову". Попытайтесть предположить, как будет действовать машина в ответ на запрос передачи 3 байт информации с машинным словом в 4 байта. В 8 байт. В 3 байта. В 6 байт.
- Последовательность бит, которую может обрабатывать процессор.
- В данных примерах передастся столько, сколько занимает машинное слово, оставшееся место будет заполнено мусором.

### 03 - Дайте определения "транслятору", "трансляции".
- Транслятор - устройство перевода кода.
- Трансляцмя - перевод кода.

### 04 - Дайте определение "ключевому слову языка". В прошлом и в некоторых эзотерических языках множество ключевых слов и множество зарезервированных слов могут различатся, сейчас можете считать определения тождественными.
- Это предварительно определенные зарезервированные идентификаторы, имеющие особое синтаксическое значение.

### 05 - Можно ли назвать переменную if? IF? If?
- if - нельзя, так как это зарезервированное слово языка.
- IF и If - можно, но не следует так делать, чтобы не затруднять чтение кода.

### 06 - Что такое точки входа и выхода? Вопросы единственности каждой из них.
- Т. входа - начало выполнения программы. Может быть только единственной в программе.
- Т. выхода - конец выполнения программы. Может быть несколко, но задействована будет только одна.

### 07 - Препроцессор языка С работает до этопа трансляции или после?
- До.

### 08 - Какие команды препроцессора вы знаете?
- include - подключение какого либо файла;
- define - определение переменных.

### 09 - Можно ли давать свои макроопределения математических констант, которые уже есть в стандартной библиотеке?
- Не следует, так как они будут меньшей точности.

### 10 - Можно ли не давать макроопределение константы, которая используется в программе более двух раз?
- Нет.

### 11 - Что определяет язык программирования? Может ли компилятор не поддерживать стандарт?
- Язык программирования определяет стандарт. Компилятор может не поддерживать этот стандарт.

### 12 - Дайте определение "стандартной библиотеке".
- Это набор отдельных файлов, которые поставляются с компилятором и которые расширяют возможности языка.

### 13 - Какие модули стандартной библиотеки вы уже знаете.
- stdio.h
- stdlib.h
- math.h

### 14 - Дайте определение "простому типу данных". Обязана ли машина обеспечивать аппаратную поддержку какого-либо типа данных?
- Тип данных, о объектах которого можно сказать следующее:
- 1. работа с объектами осуществляется с помощью конструкций языка;
- 2. внутреннее представление значений объектов может зависеть от реализации транслятора и от платформы;
- 3. объекты не включают в себя другие объекты и служат основой для построения других объектов.
- Машина обязана обеспечивать поддержку только простых типов данных.

### 15 - Какие целые типы в С вы знаете?
### 16 - Каков размер каждого из них? Дайте оценку максимального числа в каждом из них.
- short int - 2 байта - от -32000 до 32000
- int - 2-4 байта(зависит от машины) - как long int или как short int(зависит от машины)
- long int - 4 байта - от -2 миллиардов до 2 миллиардов
- long long int - 8 байт - от -2^63 до 2^63
- unsigned short int - 2 байтиа - от 0 до 65000
- unsigned int - 4 байта -  как unsigned long int или как unsigned short int(зависит от машины)
- unsigned long int - 4 байта - от 0 до 4 миллиардов
- unsigned long long int - 8 байт - от 0 до 2^64

### 17 - Как ведёт себя переменная каждого из целых типов при переполнении?
- Беззнаковые типы переполняются по кольцу.
- При переполнении знаковых типов будет неопредлёенное поведение.

### 18 - Какие типы ЧПТ в С вы знаете? Связаны ли они с типами таких же названий в других языках?
- float
- double
- Такие же названия ЧПТ можно встретить и в других языках.

### 19 - Можно ли сравнивать два ЧПТ через "двойное равно"?
- Нет, так как они могут иметь разную точность.

### 20 - Как правильно сравнивать два ЧПТ? Как правильно сравнивать два ЧПТ, учитывая предположение, что все используемые ЧПТ близки к единице по модулю?
- Правильно сравнивать ЧПТ с использованием eps(малого числа, точности которого хватит для сравнения двух ЧПТ).

### 21 - Дайте определение "значащему разряду".
- Любая цифра числа, начиная с первой слева ненулевой цифры.

### 22 - (1e-12 + 1e+12)
- 1e+12

### 23 - (1e-12 - 1e+12)
- -1e+12

### 24 - (1e-16 + 1e-17)
- 1.1e-16

### 25 - Могут ли машина и человек предполагать разную точность у полученного в ходу вычислений ЧПТ?
- Да.

### 26 - Напишите чему равен игрек
	y = 3.1234567891234 + 2.1f;
- y = 5.2234567891234

### 27 - Как мы будем выбирать для решения типы данных.
- Если в задаче требуется большая точность то используем double. Если в программе слишком много переменны, то можно пожертвовать точностью взамен на меньшее количество испульзуемой памяти.
- Выбор целочисленного типа зависит от размера чисел ав программе.

### 28 - Как работает приведение типов в С? Явное? Неявное?
- Явное приведение задаётся программистом в тексте программы с помощью конструкции языка или функции, принимающей значение одного типа и возвращающей значение другого типа.
- Неявное приведение выполняется транслятором по правилам, описанным в стандарте языка. Оно происходит в следующих случаях:
- 1. после вычисления операндов бинарных арифметических, логических, битовых операций, операций сравнения, а также 2-го или 3-го операнда операции «?:»; значения операндов приводятся к одинаковому типу;
- 2. перед выполнением присваивания;
- 3. перед передачей аргумента функции;
- 4. перед возвратом функцией возвращаемого значения;
- 5. после вычисления выражения конструкции switch значение приводится к целочисленному типу;
- 6. после вычисления выражений конструкций if, for, while, do-while значение приводится к типу bool.

### 29 - В выражении 4 <= 3.9 транслятор сначала приведет левого к double, и только потом сравнит?
- Да.

### 30 - Можно ли поменять тип у переменной?
- Нет.

### 31 - Распишите "таблички неявного приведения" для четырёх арифметических операций над числами типов long int, long long int, float, double, int32_t, int64_t. Должны получится четыре матрицы 6х6, особое внмание обратите на ситуации с двумя числами разной точности и/или разного объёма.
|           | int       | long      | long long | float   | double  |
|-----------|-----------|-----------|-----------|---------|---------|
| int       | int       | long      | long long | float   | double  |
| long      | long      | long      | long long | float   | double  |
| long long | long long | long long | long long | double  | double  |
| float     | float     | float     | double    | float   | double* |
| double    | double    | double    | double    | double* | double  |
double* - double с точностью float.
### 32 - Может ли целое число служить логическим выражением?
- Да.

### 33 - Какое целое число всегда ложно? Только ли оно?
- Всегда ложно только одно целое число - 0.

### 34 - Определён ли порядок арифметических вычислений?
- Да, слева направо.

### 35 - Укажите порядок выполнения операций:
	a + b + c + a + c + d + b
- Действия слева направо.

### 36 - Укажите порядок выполнения операций:
	f(a) + f(b) + f(f(a))
- Порядок определить невозможно.

### 37 - Какие особенности вычислений с ЧПТ, в частности, будет ли оптимизировано вычисление:
	x = y - y;
	x = y/y;
- Точность результата будет зависеть от порядка вычислений.
- Примеры будут оптимизированы, только если будут вычисления с целыми числами, с ЧПТ оптимизации происходить не будет.

### 38 - Определён ли порядок вычисления "аргументов"(левого и правого операндов) логических И/ИЛИ?
- Да, слева направо.

### 39 - Можем ли мы так писать?
```c
	if(scanf("%ld", &x)=1 && x>0)
```
- Данная строка вызовет ошибку, так как мы пытаемся присвоить к scanf 1. Верной будет строка:
```c
	if (scanf("%ld", &x) == 1 && x > 0)
```

### 40 - Что получится в результате?
	27 && 13 && 1 && 12
- 27

### 41 - Дайте определение "операторным скобкам".
- Скобки или команды, определяющие в языке программирования блок команд, воспринимаемый как единое целое.

### 42 - Какова конструкция условного оператора?
```c
	if (...)
	{
		...;
	}
	else if (...)
	{
		...;
	}
	else
	{
		...;
	}
```
- Если в блоке исполняется только одна команда, фигурные скобки можно опустить.

### 43 - Какие виды циклов вы знаете? Какие ключевые слова использует каждый из них?
- Цикл с предусловием.
```c
	while (...)
	{
		...;
	}
```
- Цикл с постусловием.
```c
	do
	{
		...
	}
	while (...);
```
- Цикл с параметром.
```c
	for (parametr; requirement; action)
	{
		...;
	}
```
### 44 - Чем отличаются выражения и инструкции? Можно ли писать
```c
	for(a=2;for(a=2; a<54; a++);a++) - нет.
	for(for(a=2; a<54; a++);a<54;a++) - нет.
	for(a=2;a<54;for(a=2; a<54; a++)) - да, если переменная a объявлена до цикла.
```

- Инструкции - это фрагмент кода, который выполняется какое-то определенное действие, другими словами является командой.
- Выражение - это фрагмент кода (некая комбинация значений, переменных, операций и функций), который в ходе своего выполнения приводит к вычислению и возврату некоторого значения (например, числа, строки или значения логического типа). Оно вычисляется и даёт какой-то результат. А если выражение стоит в отдельной строке кода, то это уже считается инструкцией.

### 45 - Можно ли через один цикл переписать любой другой? Если да, то через какой?
- Через цикл с предусловием можно переписать все другие.
```c
	while (...)
	{
		...;
	}
```

### 46 - Дайте определение "числовой последовательности", "рекуррентной формуле", "простой рекуррентной формуле".
- Числовая последовательность - это последовательность чисел.
- Рекуррентная формула - формула, выражающая каждый член последовательности через предыдущие.

### 47 - Как читать квантор суммы?
- Сумма всех элементов от aj до ak.

### 48 - Можно ли посчитать ..., если последовательность ai не является сходящейся.
- Нет.

### 50 - Какие части отношения ai/(ai - 1) мы пытаемя сохранить и почему, а какие нет?
- Мы стараемся сократить повторяющиеся части, чтобы избежать повторных вычислений.
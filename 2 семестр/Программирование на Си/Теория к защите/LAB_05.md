# Лабораторные работы теория

## ЛР 5

## Запись как структура данных

### 01 - Дайте определение записи со статическими полями.
- Объединение нескольких объектов, возможно, различного типа под одним именем, которое является типом структуры.

### 02 - Определён ли порядок инициализации полей при объявлении записи?
- Да, обязательно в таком же порядке в котором они идут в описании самой записи.

### 03 - Как можно обратится к полю записи и полю записи под указателем?
- a.field
- a->field

### 04 - Что происходит при присваивании записей?
- Присваиваются соответсвующие поля.

### 05 - Дайте определение выравниванию полей записи в памяти. Кто осуществляет выравнивание? Какова причина?
- Расположение полей в памяти по адресам, компилятором, с целью оптимизации доступа.

### 06 - Как можно определить объём занимаемой записью памяти?
```c
	struct s
	{
		...
	} a;
	printf("%d", sizeof(a))
```
- Или же можно посчитать. Компилятор с целью оптимизации доступа располагает поля в памяти по адресам кратным размеру поля.
- Однобайтовые поля не выравниваются, двухбайтовые - выравниваются на чётные позиции, четырехбайтовые - на позиции кратные четырём и т.д.

### 07 - Дайте определение упаковки записей.
- Расположение данных в памяти соответственно требованиям низкоуровневого протокола или оборудования.

### 08 - Есть ли упоминание упаковки записей в стандарте?
- Да, с помощью директивы pragma.

### 09 - В каких случаях рекомендуется пользоваться упаковкой и почему?
- Когда необходимо, чтобы расположение данных в памяти точно соответствовало требованиям низкоуровневого протокола или оборудования. 

### 10 - Какова мотивация к использованию массива записей перед использованием совокупности массивов?
- Удобнее. Проще понимать код.

### 11 - Дайте определение устойчивой сортировки.
- Сортировка, в процессе которой не меняется относительный порядок никаких двух элементов, одинаковых с точки зрения компаратора.

### 12 - Может ли неустойчивая сортировка показать такой же результат, что и устойчивая?
- Да.

### 13 - Какие вы знаете устойчивые алгоритмы сортировки?
- Сортировка пузырьком, сортировка вставками, шейкер сортировка.


## Файл как структура данных

### 01 - Дайте определение последовательному доступу к информациию Чем он отличается от произвольного доступа?
- Доступ, при котором очередной элемент можно прочитать(записать) только после аналагичной операции с предыдущим элементом. 
- При произвольном доступе выполняется чтение(запись) произвольного элемента по заданному адресу.

### 02 - Дайте определение физическому файлу.
- Именованная область памяти, предназначенная для хранения информации.

### 03 - Дайте определение сектору и сегменту.
- Сектор - минимальная единица размещения.
- Сегмент - условно выделенная область адресного пространства определённого размера.
### 04 - Можно ли провести аналогию между сектором и минимальной единицей адресации?
- Да. В секторе не может быть больше одного файла, так как это минимальная единица размещения, а в минимальной единице адресации не может быть больше 1 переменной.

### 05 - Дайте определение фрагментации файла.
- Процесс, при котором файл при записи на диск разбивается на блоки различной длины, которые записываются в разные области жесткого диска.

### 06 - Должна ли отличатся организация доступа в программе к фрагментированному файлу от организации доступа к нефрагментированному файлу?
- Нет.

### 07 - Почему мы акцентируем внимание на фрагментации файла, хотя абстрагируемся от внутреннего устройства оперативной памяти?
- Несмотря на то, что мы абстрагируемся от внутреннего устройства оперативной памяти, нужно знать как работать с фрагментированными и нефрагментированными файлами.

### 08 - Дайте определение расширению файла.
- Последовательность символов, добавляемых к имени файла и предназначенных для идентификации формата файла.

### 09 - Влияет ли изменение расширения файла на содержимое?
- Нет.

### 10 - Дайте определение файловой переменной.
- Переменная, используемая для обозначения файла и обращения к нему.

### 11 - Дайте определение точки связывания, точки открытия, точки закрытия.
-  Точка связывания: место в программе, связывающее переменную с файлом.
- Точка открытия: место в программе, открывающее файл.
- Точка закрытия: место в программе, закрыывающее файл.

### 12 - Различаются ли в Си точка связывания и точка открытия файла?
- Нет.

### 13 - Можно ли два раза подряд закрыть один и тот же файл?
- Нет, при повторной попытке закрытия файла функция fclose вернет код EOF, тем самым показывая, что произошла ошибка.

### 14 - Дайте определение текстовому файлу.
- Файл, содержащий текстовые данные.

### 15 - За что отвечают переменные stdin, stdout и stderr?
- stdin - Стандартный поток ввода (сокращение от standard input). Обычно этот поток связан с клавиатурой. Программа может читать из него данные.
- stdout - Стандартный поток вывода (сокращение от standard output). Обычно этот поток связан с дисплеем. Программа может выводить в него данные.
- stderr - Стандартный поток ошибок (сокращение от standard error). Обычно этот поток связан с дисплеем. Программа может выводить в него сообщения об ошибках.

### 16 - Как организованы режимы чтения, записи, дозаписи, псевдопроизвольного доступа?
- Сначала изменяется внутренний указатель положения в файле. После все преобразования.

### 17 - Дайте определение бинарному файлу.
- Последовательность произвольных байтов, они часто имеют сложную внутреннюю структуру, например, объектный код программы или архивный файл.

### 18 - Перечислити основные макроопределения для работы с бинарными файлами.
- EOF, SEEK_CUR, SEEK_END, SEEK_SET.

### 19 - Дайте определение типизированному файлу.
- Это файл, все компоненты которого одного типа.

### 20 - Существует ли интерфейс в языке Си для работы с типизированными файлами?
- Нет.

### 21 - Предложите свою реализацию функций для работы с типизированным файлом целых чисел по аналогии с массивом целых чисел.
- Вместо изменения номера элемента массива изменяется внутренний указатель положения в файле.
- Переменные считываются не в массив, а по одной во временную переменную, и с ней уже выполняются преобразования.

### 22 - Какова мотивация к использованию типизированного файла перед использованием массива в памяти?
- В работе может использоваться столько данных, что они не уместятся в ОЗУ.

### 23 - Расскажите о работе с внешними ресурсами по отношению к программе на примере работы с файлом. Можно ли не закрывать файл?
- Их нужно своевременно закрывать, чтобы избежать ошибок.
- Файл можно не закрывать, так как после завершения программы операционная система освобождает все ресурсы, которые программа использовала. Но лучше закрывать файл по некоторым причинам:
- 1. У программы может быть ограничение на количество одновременно открытых файлов. Если не закрывать неиспользуемые, то может произойти ошибка открытия очередного файла.
- 2. В Windows когда программа открывает файл, другие программы не могут его открыть или удалить. Поэтому если файл может кому-то понадобиться и, до окончания работы программы ещё далеко, то нужно его закрыть.
- 3. Вывод в файл совершается не сразу, а через вспомогательный буфер. Это сделано для ускорения процесса вывода. Поэтому при закрытии файла выполняется запись буферизованных, но ещё не записанных данных. Если же файл не был закрыт, то буферизованные данные могут быть потеряны. Поэтому лучше закрывать файл,чтобы гарантированно увидеть всё, что вывела программа.

### 24 - Раскажите о разделении функций на два множества относительно работы с внешними ресурсами согласно правилу Тараса Бульбы.
- Функция должна закрыть файл, если его открыла и не должна его закрывать, если его не открывала.

## Аргументы командной строки.

### 01 - Расскажите об аргументах командной строки.
- Часто данные передаются в программу из командной строки при ее запуске. Если программа написана на языке Си, то после ее запуска управление передается в функцию main, которая и должна получить аргументы из командной строки. Для этого  в стандарте языка определен еще один прототип функции main, который выглядит следующим образом
	int main(int argc, char** argv);
- Данный вариант функции main получает два параметра:
- 1. целое число (argc), обозначающее количество аргументов (элементов, разделенных пробелами) в командной строке при вызове (следует иметь в виду, что само имя программы также учитывается),
- 2. указатель на массив строк (argv), где каждая строка – это отдельный аргумент из командной строки.
- То, что в программу передаются данные, не означает, что функция main должна их обрабатывать. Если функция main определена без параметров (int main(void)), то получить доступ к аргументам командной строки невозможно.
- Имена argc и argv не являются обязательными, но лучше придерживаться именно их, чтобы ваши программы были более понятны другим программистам.

### 02 - Почему все данные, передаваемые пользователем, хранятся в виде строк?
- Это оптимальный вариант чтения. Программа не знает, что введет пользователь, а при использованиии строк пользователь может ввести любые символы(числа, буквы и т.д.).
***Конструктор***:

-   не может быть статическим
-   не может быть константным
-   не может быть виртуальным
-   не может быть валотальным
-   -
-   может быть const export
-   может быть  explicit

  

Виды конструкторов:

-   *по умолчанию* (не принимает параметры, создается конструктор копирования по умолчанию)
-   *переноса*

```c++
class Array final
{
  	private:
  		double x arr;
  		int count;
  public:
  	explicit Array(const Array& a) = delete;
  	Array(Array&& a);
  	Array() = default;
};

Array::Array(const Array& a)
{
  this->count = a.count;
  this->arr = new doiuble[this->count];
  memcpy(this->arr, a.arr, this->count * sizeof(double));
}

Array::Array(Array&& a)
{
  this->count = a.count;
  this->arr = a.arr;
  a.arr =  nullptr;
}
```

Модификатор explicit, если попопробуем передать по значению.

```c++
class Complex
{
  private:
  	double re, im;
  public:
  	Complex()
    Complex(double r)
		Complex(double r, double i):re(r), im(i){}
  	Complex(const Complex& c);
  	Complex(Comlex&& c);
    
  	Complex(initializer_list <double> list); // начиная с 11 версии
        
  	static Complex sum(const Complex& c1, const Complex& c2)
    {
      complex ctmp(c1.re + c2.re, c1.im + c2.im);
      return ctmp;
    }

    void set(int r);
  	void set(double) = delete;
};

Complex a(), 							// функция
		b1, b2{}, b3 = {},  			// объект
		c1(1.),							// конструктор с одним параметром | будет
		c2{2.}, c3 = {3},				// конструктор с одним параметром | ошибка
		c4 = 4.,				 		// конструктор с одним параметром | с explicit
		c5 = Complex(5.), 				// конструктор с одним параметром
		d1(1., 2.),						// конструктор с двумя параметрами
		d2 = Complex(3., 4.),			// конструктор с двумя параметрами
		d3{5., 6}, d4 = {7., 8.}, d5 = Complex({9., 10.}), // с двумя параметрами
		e1(d1), e2{d2},					// конструктор копирования
		e3 = {d3}, c4 = Complex(d4),	// конструктор копирования
		c5 = Complex({d5}),				// конструктор копирования
		f1 = Complex::sum(x1, c2);		// конструктор переноса
```
